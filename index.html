<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moon → Earth: Return Flight</title>
<style>
  :root{
    --bg:#06071a;
    --panel:#0f1724;
    --accent:#4ef0c6;
    --danger:#ff6b6b;
    --muted:#98a0b3;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter, Pretendard, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body {display: flex;
  align-items: center;
  justify-content: center;
  background-image: url("space.jpg");
  background-size: cover;     
  background-position: center; 
  background-repeat: no-repeat;
  }

  .game-wrap{
    width:min(1100px, 96vw);
    aspect-ratio:16/9;
    display:grid;
    grid-template-columns: 1fr 260px;
    gap:12px;
  }

  /* Game canvas panel */
  .stage{
    background-color: #1B2139;
    border-radius:5px;
    padding:5px;
    position:relative;
    overflow:hidden;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  canvas{width:100%;height:100%;display:block;border-radius:8px;background:transparent;}

  /* Side panel */
  .panel{
    background-color: #15192C;
    border-radius:5px;
    padding:10px;
    color:var(--muted);
    display:flex;
    flex-direction:column;
    gap:15px;
    min-height:0;
  }
  .panel h2{margin:0;color:var(--accent);font-size:15px}
  .stat{display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
  .bar {
    height:10px;background:rgba(255,255,255,0.04);border-radius:9px;overflow:hidden;margin-left:10px;flex:1;
  }
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#8ef6d4);}

  .controls{font-size:13px;color:#bcdad1}
  .btn{
    display:inline-block;padding:8px 12px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.06);
    color:var(--accent);cursor:pointer;margin-right:6px;
  }
  .hud{
    position:absolute;
    left:15px;
    top:40px; /* 위에서 40px 아래로 */
    padding:8px 12px;
    border-radius:8px;
    background:rgba(2,6,23,0.6);
    font-size:13px;
    color:#cdefe2;
}
  .center-overlay{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;
    background:linear-gradient(180deg, rgba(0,0,0,0.70), rgba(0,0,0,0.75));padding:30px;border-radius:10px;
  }
  .hidden{display:none}
  footer.small{font-size:12px;color:var(--muted);text-align:center;margin-top:auto}
</style>
</head>


<body>
<div class="game-wrap">
  <div class="stage" id="stage">
    <canvas id="canvas"></canvas>

    <div class="hud" id="hud">Go To Home</div>

    <div id="overlay" class="center-overlay">
      <h1 style="margin:0;color:var(--accent)">Escape the Planet</h1>
      <p style="color:#c9eedd;margin:15px 0 10px">행성을 무사히 탈출하세요</p>
      <div>
        <button id="startBtn" class="btn">Start</button>
        <button id="tutorialBtn" class="btn">How to play</button>
      </div>
    </div>

    <div id="message" class="center-overlay hidden" style="width:60%;"></div>
  </div>

  <aside class="panel">
    <h2></h2>
    <h2>Status</h2>
    <div class="stat"><div>Health</div><div style="display:flex;align-items:center"><div class="bar" style="width:140px"><i id="hpBar" style="width:100%"></i></div><div id="hpText" style="margin-left:8px">100</div></div></div>
    <div class="stat"><div>Fuel</div><div style="display:flex;align-items:center"><div class="bar" style="width:140px"><i id="fuelBar" style="width:100%"></i></div><div id="fuelText" style="margin-left:8px">100</div></div></div>
    <div class="stat"><div>Score</div><div style="font-weight:700;color:#e6fff7" id="scoreText">0</div></div>

    <div>
      <h2>Tip</h2>
      <ul style="margin:10px; font-size: 15px; margin-left: -40px;">
        <div>연료를 관리하세요</div>
        <div>원석을 모아보세요</div>
      </ul>
    </div>

    <div>
      <h2>Controls</h2>
      <div class="controls" style = "margin: 10px; margin-left: 0px; font-size: 15px;">
        ↑/↓/←/→ : 이동<br>
        Space : 공격<br>
        P : 일시정지 / R : 재시작
      </div>
    </div>

    <footer class="small"></footer>
  </aside>
</div>

<script>
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const rand = (a,b)=>a + Math.random()*(b-a);

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W=0,H=0, DPR = Math.min(window.devicePixelRatio||1,2);

function resize(){
  const rect = canvas.getBoundingClientRect();
  W = Math.floor(rect.width * DPR);
  H = Math.floor(rect.height * DPR);
  canvas.width = W;
  canvas.height = H;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);

// ---- Game State ----
let playing=false, paused=false;
let lastTime=0;
let keys = {};
let bullets = [];
let obstacles = [];
let particles = [];
let score = 0;

const STATE = {
  player: {
    x: 120, 
    y: 0,
    vx: 0,
    vy: 0,
    radius: 14,
    hp: 100,
    fuel: 100,
    shotCooldown: 0
  },
  world: {
    width: 4000, 
    spawnX: 2000,
  },
  camera: { x:0, y:0, w:0, h:0 },
  goal: { x: 3800, w:200 } 
};

function initPositions(){
  STATE.player.y = H / DPR / 2;
  STATE.camera.x = 0;
  STATE.camera.y = 0;
  STATE.camera.w = canvas.width / DPR;
  STATE.camera.h = canvas.height / DPR;
}
resize();
initPositions();


window.addEventListener('keydown', e=>{
  if(e.key===' '){ e.preventDefault(); } 
  keys[e.key.toLowerCase()] = true;

  if(e.key.toLowerCase() === 'p'){ paused = !paused; showTempMessage(paused ? 'Paused' : 'Resumed', 800); }
  if(e.key.toLowerCase() === 'r'){ restartGame(); }
});
window.addEventListener('keyup', e=>{
  keys[e.key.toLowerCase()] = false;
});

// ---- Start / UI ----
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const tutorialBtn = document.getElementById('tutorialBtn');
const messageBox = document.getElementById('message');
startBtn.addEventListener('click', ()=>{ overlay.classList.add('hidden'); startGame(); });
tutorialBtn.addEventListener('click', ()=>{ showTempMessage('방향키로 위치를 움직이고<br>스페이스바로 공격할 수 있습니다.', 1000); });

// HUD elements
const hpBar = document.getElementById('hpBar');
const fuelBar = document.getElementById('fuelBar');
const hpText = document.getElementById('hpText');
const fuelText = document.getElementById('fuelText');
const scoreText = document.getElementById('scoreText');
const hud = document.getElementById('hud');

// Message util
let msgTimeout = null;
function showTempMessage(txt, ms=1000){
  messageBox.innerHTML = `<h2 style="margin:0;color:var(--accent)">${txt}</h2>`;
  messageBox.classList.remove('hidden');
  clearTimeout(msgTimeout);
  msgTimeout = setTimeout(()=>messageBox.classList.add('hidden'), ms);
}


function startGame(){
  // reset state
  playing = true;
  paused = false;
  lastTime = performance.now();
  bullets = [];
  obstacles = [];
  particles = [];
  score = 0;
  STATE.player.x = 120;
  STATE.player.y = canvas.height / DPR / 2;
  STATE.player.vx = 0;
  STATE.player.vy = 0;
  STATE.player.hp = 100;
  STATE.player.fuel = 100;
  STATE.player.shotCooldown = 0;
  generateObstacles();
  requestAnimationFrame(loop);
}

function restartGame(){
  overlay.classList.add('hidden');
  startGame();
}

// Generate obstacles across world
function generateObstacles(){
  obstacles = [];
  for(let i=0;i<120;i++){
    const typeRand = Math.random();
    const x = rand(300, STATE.world.width - 300);
    const y = rand(60, (canvas.height/DPR) - 60);
    if(typeRand < 0.45){
      obstacles.push({
        type:'ore',
        x, y,
        r: rand(8,14),
        value: Math.floor(rand(6,18)),
        vx: rand(-0.2,0.2),
        vy: rand(-0.05,0.05),
        rotation: rand(0,Math.PI*2)
      });
    } else if(typeRand < 0.85){
      // small asteroid (damage on hit)
      obstacles.push({
        type:'asteroid',
        x, y,
        r: rand(12,28),
        vx: rand(-0.6,0.6),
        vy: rand(-0.2,0.2),
      });
    } else {
      // moving hazard cluster
      obstacles.push({
        type:'cluster',
        x, y,
        r: rand(6,10),
        vx: rand(-1.2,-0.2),
        vy: rand(-0.4,0.4),
      });
    }
  }

  
  obstacles = obstacles.filter(o=>o.x > 200 && o.x < STATE.world.width - 200);
}


function spawnParticles(x,y,n,color='white'){
  for(let i=0;i<n;i++){
    particles.push({
      x, y,
      vx: rand(-2,2),
      vy: rand(-2,2),
      life: rand(400,1000),
      age:0,
      color
    });
  }
}


function loop(ts){
  if(!playing) return;
  if(paused){ lastTime = ts; requestAnimationFrame(loop); return; }

  const dt = clamp((ts - lastTime)/1000, 0, 0.05);
  lastTime = ts;

  update(dt);
  render();

  requestAnimationFrame(loop);
}

function update(dt){
  const p = STATE.player;

  
  const thrustPower = 160; 
  const acc = {x:0,y:0};
  let thrusting = false;

  if(keys['arrowup'] || keys['w']){ acc.y -= thrustPower; thrusting=true; }
  if(keys['arrowdown'] || keys['s']){ acc.y += thrustPower; thrusting=true; }
  if(keys['arrowleft'] || keys['a']){ acc.x -= thrustPower; thrusting=true; }
  if(keys['arrowright'] || keys['d']){ acc.x += thrustPower; thrusting=true; }

  
  p.vx += acc.x * dt;
  p.vy += acc.y * dt;

  p.vx *= (1 - 0.12*dt);
  p.vy *= (1 - 0.12*dt);

  if(thrusting && p.fuel > 0){
    p.fuel -= 12 * dt; 
    if(p.fuel < 0) p.fuel = 0;
  }

  // Shooting
  p.shotCooldown -= dt;
  if((keys[' '] || keys['space']) && p.shotCooldown <= 0 && p.fuel > 2){
    shoot();
    p.shotCooldown = 0.5;
    p.fuel = Math.max(0, p.fuel - 1.6);
  }

  
  const maxSpeed = 380;
  const sp = Math.hypot(p.vx,p.vy);
  if(sp > maxSpeed){
    p.vx = (p.vx / sp) * maxSpeed;
    p.vy = (p.vy / sp) * maxSpeed;
  }

  
  p.x += p.vx * dt;
  p.y += p.vy * dt;

  const worldH = canvas.height / DPR;
  p.y = clamp(p.y, 24, worldH - 24);
  p.x = clamp(p.x, 40, STATE.world.width - 20);

  const cam = STATE.camera;
  const targetCamX = clamp(p.x - cam.w*0.35, 0, STATE.world.width - cam.w);
  cam.x += (targetCamX - cam.x) * clamp(6*dt,0,1);
  cam.y = 0;

  
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt;
    if(b.life <= 0) bullets.splice(i,1);
  }

  for(let i=obstacles.length-1;i>=0;i--){
    const o=obstacles[i];
    o.x += (o.vx || 0) * dt * 60;
    o.y += (o.vy || 0) * dt * 60;

    if(o.type === 'ore' && o.rotation !== undefined){
      o.rotation += 0.02;
    }

    for(let j=bullets.length-1;j>=0;j--){
      const b=bullets[j];
      const dx = b.x - o.x, dy = b.y - o.y, d2 = dx*dx + dy*dy;
      if(d2 < (o.r + 3)*(o.r + 3)){
        // bullet hit obstacle
        bullets.splice(j,1);
        if(o.type === 'ore'){
          score += Math.round(o.value * 0.8);
          spawnParticles(o.x, o.y, 8, '#8af2d0');
          STATE.player.fuel = clamp(STATE.player.fuel + o.value*0.18, 0, 150);
          obstacles.splice(i,1);
        } else {
          score += 5;
          spawnParticles(o.x, o.y, 14, '#ffcc99');
          if(o.r > 10){
            // create two smaller pieces
            const pieces = Math.min(2, Math.floor(o.r/8));
            for(let k=0;k<pieces;k++){
              obstacles.push({
                type: 'asteroid',
                x: o.x + rand(-6,6),
                y: o.y + rand(-6,6),
                r: o.r * rand(0.4,0.7),
                vx: o.vx + rand(-1,1),
                vy: o.vy + rand(-0.6,0.6)
              });
            }
          }
          obstacles.splice(i,1);
        }
        break;
      }
    }
  }



  
  for(let i=obstacles.length-1;i>=0;i--){
    const o=obstacles[i];
    const dx = o.x - p.x, dy = o.y - p.y;
    const dist = Math.hypot(dx,dy);
    if(dist < o.r + p.radius){
      if(o.type === 'ore'){
        // collect ore
        score += o.value;
        STATE.player.fuel = clamp(STATE.player.fuel + o.value*0.25, 0, 150);
        spawnParticles(o.x, o.y, 10, '#a6ffe9');
        obstacles.splice(i,1);
      } else {
        // asteroid collision - take damage and bounce
        const impact = Math.round(o.r * 1.8);
        STATE.player.hp = Math.max(0, STATE.player.hp - impact);
        score = Math.max(0, score - Math.floor(impact * 0.5));
        // simple bounce
        p.vx -= dx * 0.03;
        p.vy -= dy * 0.03;
        spawnParticles(p.x, p.y, 18, '#ff9b9b');
        // destroy small ones
        if(o.type === 'asteroid'){
          if(o.r > 18){
            o.r *= 0.7;
          } else {
            obstacles.splice(i,1);
          }
        } else {
          obstacles.splice(i,1);
        }
      }
    }
  }

  for(let i=particles.length-1;i>=0;i--){
    const pr=particles[i];
    pr.age += dt*1000;
    pr.x += pr.vx * dt * 60;
    pr.y += pr.vy * dt * 60;
    if(pr.age > pr.life) particles.splice(i,1);
  }

  if(p.x >= STATE.goal.x && STATE.player.hp > 0){
    endGame(true);
  }

  if(!thrusting && p.fuel < 100){
    // slow fuel regen when not thrusting
    p.fuel = clamp(p.fuel + 6 * dt, 0, 100);
  }

  if(p.hp <= 0){
    endGame(false);
  }

  hpBar.style.width = (STATE.player.hp)+'%';
  fuelBar.style.width = (STATE.player.fuel)+'%';
  hpText.textContent = Math.round(STATE.player.hp);
  fuelText.textContent = Math.round(STATE.player.fuel);
  scoreText.textContent = Math.round(score);

  const remain = Math.max(0, Math.floor((STATE.goal.x - p.x) / 10));
  hud.textContent = `Distance to escape: ${remain} units  •  Speed: ${Math.round(Math.hypot(p.vx,p.vy))}`;
}

// Shooting
function shoot(){
  const p=STATE.player;
  const speed=620;
  let dirx = p.vx, diry = p.vy;
  const mag = Math.hypot(dirx,diry);
  if(mag < 60){
    dirx = 1; diry = 0;
  } else {
    dirx /= mag; diry /= mag;
  }
  bullets.push({
    x: p.x + dirx*(p.radius+6),
    y: p.y + diry*(p.radius+6),
    vx: dirx * speed,
    vy: diry * speed,
    life: 1.3
  });

  spawnParticles(p.x + dirx*(p.radius+4), p.y + diry*(p.radius+4), 4, '#c9fff0');
}

// End game
function endGame(win){
  playing = false;
  messageBox.classList.remove('hidden');
  messageBox.innerHTML = `<h2 style="margin:0;color:${win? 'var(--accent)' : 'var(--danger)'}">${win ? 'Escape Success!' : 'Escape Failed'}</h2>
    <p style="margin:10px 0 0;color:#d6eae3">Score: ${Math.round(score)} • Health: ${Math.round(STATE.player.hp)} • Fuel: ${Math.round(STATE.player.fuel)}</p>
    <div style="margin-top:12px"><button class="btn" id="retry">Play again</button></div>`;
  messageBox.classList.remove('hidden');

  document.getElementById('retry').addEventListener('click', ()=>{
    messageBox.classList.add('hidden');
    startGame();
  });
}

function render(){
  // clear
  ctx.fillStyle = '#02030b';
  ctx.fillRect(0,0, canvas.width/DPR, canvas.height/DPR);


  drawStarfield();

  drawMoon();

  drawEarth();

  const cam = STATE.camera;
  ctx.save();
  ctx.translate(-cam.x, -cam.y);

  for(const o of obstacles){
    if(o.x + o.r < cam.x - 40 || o.x - o.r > cam.x + cam.w + 40) continue;
    if(o.type === 'ore'){
      drawOre(o);
    } else {
      drawAsteroid(o);
    }
  }

  for(const b of bullets){
    drawBullet(b);
  }

  // player
  drawShip(STATE.player);

  // particles
  for(const pr of particles){
    drawParticle(pr);
  }

  ctx.restore();

  // mini progress bar at top
  drawProgressBar();
}

function drawStarfield(){
  const camX = STATE.camera.x || 0;
  const w = canvas.width/DPR;
  const h = canvas.height/DPR;

  const seed1 = Math.floor(camX/2) % 100000;
  for(let i=0;i<60;i++){
    const sx = ((i*37 + seed1*13) % 1000) / 1000 * (w + 200) - 100;
    const sy = (i*73 % 1000) / 1000 * h;
    const size = (i%7 === 0) ? 2.3 : 1.1;
    ctx.fillStyle = (i%9===0) ? '#e8fdf3' : '#8fbfd1';
    ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI*2); ctx.fill();
  }
}

function drawMoon(){
  const centerY = canvas.height/DPR/2;
  const startX = 80; 
  const camX = STATE.camera.x; 
  const x = startX - camX * 0.6;
  const y = centerY;

  ctx.save();

  const grad = ctx.createRadialGradient(x,y,10,x,y,120);
  grad.addColorStop(0,'rgba(200,210,235,0.08)');
  grad.addColorStop(1,'rgba(2,6,23,0)');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.ellipse(x,y,90,90,0,0,Math.PI*2); ctx.fill();

  
  ctx.fillStyle = '#bfcde0';
  ctx.beginPath(); ctx.ellipse(x,y,56,56,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#9aa8be';
  ctx.beginPath(); ctx.ellipse(x-14,y-8,10,8,0,0,Math.PI*2); ctx.fill();

  
  ctx.fillStyle = '#FFFFFF';
  ctx.font = '30px system-ui, Pretendard,';
  ctx.fillText('', x - 10, y + 75);

  ctx.restore();
}


function drawEarth(){
  const cx = STATE.goal.x + 60;
  const cy = canvas.height/DPR/2;
  ctx.save();
  ctx.beginPath();
  ctx.ellipse(cx, cy, 90, 90, 0, 0, Math.PI*2);
  ctx.fillStyle = '#1a6fb3';
  ctx.fill();

  ctx.fillStyle = '#2fbf7f';
  ctx.beginPath();
  ctx.ellipse(cx-20, cy-14, 34, 18, -0.4, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx+24, cy+6, 24, 14, 0.2, 0, Math.PI*2);
  ctx.fill();

  const g = ctx.createRadialGradient(cx, cy, 60, cx, cy, 140);
  g.addColorStop(0,'rgba(34,180,160,0.07)');
  g.addColorStop(1,'rgba(8,15,30,0)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.ellipse(cx, cy, 140, 140, 0, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = '#dff7ff';
  ctx.font = '13px system-ui, Pretendard, Arial';
  ctx.fillText('Earth (Goal)', cx - 34, cy + 110);
  ctx.restore();
}

function drawOre(o){
  ctx.save();
  ctx.translate(o.x, o.y);
  if(o.rotation) ctx.rotate(o.rotation);

  const r = o.r;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fillStyle = '#7ef4d6';
  ctx.fill();

  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  const grad = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
  grad.addColorStop(0, 'rgba(255,255,255,0.4)');
  grad.addColorStop(1, 'rgba(126,244,214,0.9)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawAsteroid(o){
  ctx.save();
  ctx.translate(o.x, o.y);
  ctx.beginPath();
  const bumps = Math.max(6, Math.floor(o.r/3));
  for(let i=0;i<bumps;i++){
    const ang = i/bumps * Math.PI*2;
    const rad = o.r * (0.75 + Math.sin(i*1.7 + o.x*0.001) * 0.3);
    const x = Math.cos(ang) * rad;
    const y = Math.sin(ang) * rad;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  ctx.fillStyle = '#8b8176';
  ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.stroke();
  ctx.restore();
}

function drawBullet(b){
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = '#bfffe9';
  ctx.ellipse(b.x, b.y, 3, 2, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawParticle(pr){
  const t = pr.age/pr.life;
  ctx.globalAlpha = 1 - t;
  ctx.fillStyle = pr.color || '#fff';
  ctx.beginPath(); ctx.arc(pr.x, pr.y, 1.6 + (1-t)*2.4, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
}

const spaceshipImg = new Image();
spaceshipImg.src = "alien.png";

function drawShip(p){
  const w = p.radius * 6; 
  const h = p.radius * 6;
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.drawImage(spaceshipImg, -w/2, -h/2, w, h);
  ctx.restore();
}

  // thruster flame when accelerating (if any arrow keys pressed)
  if(keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright'] || keys['w'] || keys['a'] || keys['s'] || keys['d']){
    ctx.beginPath();
    ctx.moveTo(-p.radius-2, 0);
    ctx.lineTo(-p.radius-12, -6);
    ctx.lineTo(-p.radius-12, 6);
    ctx.closePath();
    const g = ctx.createLinearGradient(-p.radius-12,0,-p.radius,0);
    g.addColorStop(0,'#ffcf8a');
    g.addColorStop(1,'#ff6b6b');
    ctx.fillStyle = g;
    ctx.globalAlpha = 0.9;
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  ctx.restore();

function drawProgressBar(){
  const w = canvas.width/DPR;
  const x = 20, y = 18, total = STATE.world.width;
  const frac = STATE.player.x / total;
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(x-2, y-6, w-40, 14);
  ctx.fillStyle = '#063b33';
  ctx.fillRect(x-2, y-6, (w-40) * frac, 14);
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(x + (w-40)*frac - 6, y-10, 6, 18);
  ctx.fillStyle = '#dff9f0';
  ctx.font = '12px system-ui, Pretendard';
  ctx.fillText(`${Math.floor(frac*100)}%`, x + (w-40)*Math.min(frac,0.98) - 10, y + 2);
  ctx.restore();
}


resize();
initPositions();


</script>
</body>
</html>
